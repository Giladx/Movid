<!--
/***********************************************************************
 ** Copyright (C) 2010 Movid Authors.  All rights reserved.
 **
 ** This file is part of the Movid Software.
 **
 ** This file may be distributed under the terms of the Q Public License
 ** as defined by Trolltech AS of Norway and appearing in the file
 ** LICENSE included in the packaging of this file.
 **
 ** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 ** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 **
 ** Contact info@movid.org if any conditions of this licensing are
 ** not clear to you.
 **
 **********************************************************************/
-->
<html>
<head>
	<title>Movid Web Admin</title>
	<script type="text/javascript">
	var widgetCreate = null,
		widgetGet = null,
		widgetPosition = null,
		widgetAddInput = null,
		widgetAddOutput = null,
		widgetClearConnectivity = null,
		widgetConnect = null,
		widgetConfigure = null,
		widgetCanvasResize = null;
	</script>
	<script type="text/javascript" src="js/processing.js"></script>
	<script type="text/javascript" src="js/jquery-1.4.2.min.js"></script>
	<script type="text/javascript" src="js/jquery-ui-1.8rc3.custom.min.js"></script>
	<script type="text/javascript" src="js/jquery.cookies.2.2.0.js"></script>
	<script type="text/javascript" src="js/movid.js"></script>
	<link rel="stylesheet" type="text/css" href="css/ui-darkness/jquery-ui-1.8rc3.custom.css"/>
	<link rel="stylesheet" type="text/css" href="css/gui.css"/>
</head>
<body>

<div class="fg-toolbar ui-widget-header ui-corner-bottom ui-helper-clearfix">
	<div class="fg-buttonset">
		<div class="fg-button ui-fake">Movid <span id="version">??</span></div>
	</div>
	<div class="fg-buttonset">
		<a class="fg-button ui-state-default ui-corner-all" id="btn-start">Start</a>
	</div>
	<div class="fg-buttonset">
		<a class="fg-button ui-state-default ui-corner-all" id="btn-preview">Preview</a>
		<a class="fg-button ui-state-default ui-corner-all" id="btn-create">Create</a>
		<a class="fg-button ui-state-default ui-corner-all" id="btn-module">Module</a>
		<a class="fg-button ui-state-default ui-corner-all" id="btn-properties">Properties</a>
	</div>
	<div class="fg-buttonset">
		<div class="fg-button ui-fake" id="toolbareport"></div>
	</div>
</div>

<div id="wrapper">

<div id="leftcolumn">
	<div class="ui-widget ui-widget-sidebar" id="container-create">
		<div class="ui-widget-header ui-state-default ui-corner-top"><a href="#" onclick="$('#modules').slideToggle('fast')">Create</a></div>
		<div id="modules" class="ui-widget-content ui-corner-bottom">
		</div>
	</div>

</div>

<div id="content" class="ui-widget ui-widget-sidebar">

<div class="ui-widget-header ui-state-default ui-corner-top">
	<a href="#">Playground</a>
</div>
<div class="ui-widget-content">
<script id="movidpjs" type="application/processing" target="movidcanvas">

/* Cookie expiration in 60 days
 */
days = 60;
CookieExpires = new Date();
CookieExpires.setTime( CookieExpires.getTime() + ( 60 * 60 * 1000 * 24 * days ) );
$.cookies.setOptions({ expiresAt: CookieExpires });

//
// Class that represent a connectivity of IO of a widget
//
class IOWidget {
	String name = '';
	String type = '';

	ArrayList observers;
	ArrayList observers_idx;

	IOWidget(String _name, String _type) {
		name = _name;
		type = _type;
		observers = new ArrayList();
		observers_idx = new ArrayList();
	}

	void connect(Widget _w, int _idx) {
		observers.add(_w);
		observers_idx.add(_idx);
	}

	void clearConnectivity() {
		for ( int i = 0; i < observers.size(); i++ ) {
			observers.remove(observers.get(0));
			observers_idx.remove(observers_idx.get(0));
		}
	}
}

//
// Class that represent a Widget
//
class Widget {
	int x = 50;
	int y = 50;
	int w = 120;
	int h = 75;
	String name = 'UnknownID';
	int gui = 0;
	ArrayList inputs;
	ArrayList outputs;

	Widget() {
		inputs = new ArrayList();
		outputs = new ArrayList();
	}

	int getInputCount() {
		return inputs.size();
	}

	int getOutputCount() {
		return outputs.size();
	}

	IOWidget getInput(int idx) {
		return inputs[idx];
	}

	IOWidget getOutput(int idx) {
		return outputs[idx];
	}

	bool collide(int _x, int _y) {
		return _x >= x && _x <= x + w && _y >= y && _y <= y + h;
	}

	int collideInput(int _x, int _y) {
		_h = headerSize();
		if ( _x < x || _x > x + 20 )
			return -1;
		if ( _y < _h || _y >= _h + inputs.size() * 20 )
			return -1;
		_y -= _h;
		_y = _y / 20;
		idx = Math.floor(_y);
		if ( _y - idx <= 0.75 )
			return idx;
		return -1;
	}

	int collideOutput(int _x, int _y) {
		_h = headerSize();
		if ( _x < x + w - 20 || _x > x + w )
			return -1;
		if ( _y < _h || _y >= _h + outputs.size() * 20 )
			return -1;
		_y -= _h;
		_y = _y / 20;
		idx = Math.floor(_y);
		if ( _y - idx <= 0.75 )
			return idx;
		return -1;
	}

	void draw() {
		drawBox();
		drawInputs();
		drawOutputs();
	}

	void drawInputs() {

		_x = x;
		_y = headerSize();
		for ( int i = 0; i < inputs.size(); i++ ) {
			fill(250, 150, 50);

			for ( int j = 0; j < widgets_hover.size(); j++ ) {
				o = widgets_hover[j];
				if ( this != o[0] || o[1] != 'input' || o[2] != i )
					continue;
				fill(0x8b, 0xea, 0x00);
				break;
			}

			rect(_x, _y, 15, 15);
			_y += 20;
		}
	}

	void drawOutputs() {

		_x = x + w - 15;
		_y = headerSize();
		for ( int i = 0; i < outputs.size(); i++ ) {
			fill(250, 150, 50);

			for ( int j = 0; j < widgets_hover.size(); j++ ) {
				o = widgets_hover[j];
				if ( this != o[0] || o[1] != 'output' || o[2] != i )
					continue;
				fill(0x8b, 0xea, 0x00);
				break;
			}

			rect(_x, _y, 15, 15);
			_y += 20;
		}
	}

	void drawBox() {
		bool do_draw = false;

		// box
		fill(204, 102, 0);
		rect(x, y, w, h);

		fill(250, 150, 50);
		rect(x, y, w, textHeight(name) + 6);

		// text
		fill(255, 255, 255);
		text(name, x + (w - textWidth(name)) / 2, y + textHeight(name) + 2);

		// is widget is selected ?
		if ( mo_widget_selected == name ) {
			stroke(230, 230, 230);
			do_draw = true;

		// or is widget is currently selected for connectivity ?
		} else if ( connectivity_widget == this ) {
			stroke(0x6b, 0xca, 0x00);
			do_draw = true;

		// or is widget is currently in hover state ?
		} else {
			for ( int i = 0; i < widgets_hover.size(); i++ ) {
				o = widgets_hover[i];
				if ( this != o[0] )
					continue;
				stroke(0xd0, 0xd0, 0xd0);
				do_draw = true;
				break;
			}
		}

		if ( do_draw ) {
			noFill();
			rect(x-1, y-1, w+2, h+2);
			noStroke();
		}
	}

	int headerSize() {
		return y + textHeight(this.name) + 10;
	}

	int getInputX(int idx) {
		return x + 15 / 2.;
	}

	int getOutputX(int idx) {
		return x + w - 15 / 2.;
	}

	int getInputY(int idx) {
		return headerSize() + idx * 20 + 15 / 2.;
	}

	int getOutputY(int idx) {
		return headerSize() + idx * 20 + 15 / 2.;
	}

	void clearConnectivity() {
		for ( int i = 0; i < inputs.size(); i++ ) {
			inputs[i].clearConnectivity();
		}
		for ( int i = 0; i < outputs.size(); i++ ) {
			outputs[i].clearConnectivity();
		}
	}
}

//
// link with UI
//

widgetCreate = function(String _name, int have_gui) {
	Widget w = new Widget();
	w.name = _name;
	w.gui = have_gui;
	widgets.add(w);
}

widgetGet = function(String _name) {
	for ( int i = 0; i < widgets.size(); i++ )
		if ( widgets.get(i).name == _name )
			return widgets.get(i);
	return null;
}

widgetPosition = function(String _name, int _x, int _y) {
	Widget w = widgetGet(_name);
	if ( w == null )
		return;
	w.x = parseInt(_x);
	w.y = parseInt(_y);
}

widgetAddInput = function(String _key, String _name, String _type) {
	Widget w = widgetGet(_key);
	if ( w == null )
		return;
	IOWidget io = new IOWidget(_name, _type);
	w.inputs.add(io);
}

widgetAddOutput = function(String _key, String _name, String _type) {
	Widget w = widgetGet(_key);
	if ( w == null )
		return;
	IOWidget io = new IOWidget(_name, _type);
	w.outputs.add(io);
}

widgetClearConnectivity = function() {
	for ( int i = 0; i < widgets.size(); i++ ) {
		Widget w = widgets.get(i);
		w.clearConnectivity();
	}
}

widgetConnect = function(_out, _outidx, _in, _inidx) {
	Widget wout = widgetGet(_out),
		   win = widgetGet(_in);
	if ( win == null )
		return;
	wout.outputs.get(parseInt(_outidx)).connect(win, parseInt(_inidx));
}

widgetCanvasResize = function(w, h) {
	try {
		size(w, h);
	} catch (e) { }
}

//
// declarations
//

int fontsize = 11;
PFont fontA = loadFont("monospace");
ArrayList widgets;
int selected_widget = -1;
int selected_widget_x = 0;
int selected_widget_y = 0;
Widget selected_input_widget;
int selected_input_idx = -1;
Widget selected_output_widget;
int selected_output_idx = -1;
Widget connectivity_widget;
String connectivity_io;
int connectivity_idx;
int connectivity_ok = 0;
int config_show = 0;
int screen_w = 800;
int screen_h = 600;
int oldmouseX = 0;
int oldmouseY = 0;
color cok = color(0, 0xcc, 0);
color cko = color(0xcc, 0, 0);
color cidle = color(0xc5, 0x00, 0x80);
color cselected = color(0x8b, 0xea, 0x00);
ArrayList widgets_hover;

widgetConfigure = function(guicommand, is_update) {
	if ( is_update == 0 && config_show == 1 ) {
		config_show = 0;
		return;
	}

	config_show = 1;
	config_insts = guicommand.split("\n");
	draw();
}

void configDraw() {
	if ( config_show == 0 )
		return;

	//mo_gui(mo_widget_selected);

	// biggest task. decompile draw instruction
	// and convert to processing one.
	fill(255, 255, 255);
	var y = 10;
	var viewport_w = 1;
	var viewport_h = 1;
	function tb(x, a) {
		if (x <= 0) return 1;
		if (x >= a) return a - 1;
		return x
	}
	function ttw(s) { return tw(parseInt(s)); }
	function tth(s) { return th(parseInt(s)); }
	function tw(x) { return tb(x * screen_w / viewport_w, screen_w); }
	function th(x) { return tb(x * screen_h / viewport_h, screen_h); }
	for ( var index in config_insts ) {
		var args = config_insts[index].split(" ");

		switch ( args[0] ) {
			case '':
				break;

			case 'viewport':
				viewport_w = parseInt(args[1]);
				viewport_h = parseInt(args[2]);
				break;
				
			case 'color':
				fill(parseInt(args[1]), parseInt(args[2]), parseInt(args[3]));
				break;

			case 'rect':
				rect(ttw(args[1]), tth(args[2]), ttw(args[3]), tth(args[4]));
				break;

			case 'circle':
				ellipse(ttw(args[1]), tth(args[2]), ttw(args[3]), ttw(args[3]));
				break;

			case 'line':
				line(ttw(args[1]), tth(args[2]), ttw(args[3]), tth(args[4]));
				break;

			default:
				fill(150, 150, 150);
				text('cmd:' + args[0], 10, y);
				fill(255, 255, 255);
				y += 10;
		}
	}
}

void configSendFeedback(type, x, y) {
	mo_set(mo_widget_selected, "gui_feedback", "" + type + ";" + x + ";" + y, function() {
		// nothing.
	});
}


int textWidth(String s) {
	return s.length * (fontsize / 2) + (s.length - 1);
}

int textHeight(String s) {
	return fontsize;
}

update = function() {
	setTimeout('update()', 500);
	if ( config_show )
		mo_gui(mo_widget_selected);
}

void setup() {
	frameRate(5);
	noStroke();
	textFont(fontA, fontsize);
	widgets = new ArrayList();
	widgets_hover = new ArrayList();
	setTimeout('update()', 500);
}

void draw() {
	Widget w;

	background(51);

	if ( config_show == 1 ) {

		configDraw();

	} else {

		searchConnectivity();

		for ( int i = 0; i < widgets.size(); i ++ ) {
			w = widgets.get(i);
			if ( selected_widget == i ) {
				w.x = mouseX - selected_widget_x;
				w.y = mouseY - selected_widget_y;
			}
			w.draw();
		}

		checkConnectivity();
		drawConnectivity();

	}

	frameCount += 1;
	$('#framecount').html(frameCount);

	// reset mouse
	oldmouseX = mouseX;
	oldmouseY = mouseY;
}

void coolLine(int x0, int y0, int x1, int y1) {
	bool left;
	int delta;

	delta = 15;
	ydelta = (y1 - y0) / 10;

	xmid = x0 + (x1 - x0) / 2;

	if ( x1 - delta < x0 + delta ) {
		ymid = y0 + (y1 - y0) / 2;
		line(x0, y0, x0 + delta, y0);
		line(x0 + delta, y0, x0 + delta, ymid);
		line(x0 + delta, ymid, x1 - delta, ymid);
		line(x1 - delta, ymid, x1 - delta, y1);
		line(x0 + delta, ymid, x1 - delta, ymid);
		line(x1 - delta, y1, x1, y1);
	} else {
		xmid = x0 + (x1 - x0) / 2;
		line(x0, y0, xmid, y0);
		line(xmid, y0, xmid, y1);
		line(xmid, y1, x1, y1);
	}
	
	/**
	beginShape();
	if ( x1 - delta < x0 + delta ) {
		// FIXME
		ymid = y0 + (y1 - y0) / 2;
		curveVertex(x0, y0);
		curveVertex(x0, y0);
		curveVertex(x0 + delta, y0);
		curveVertex(x0 + delta, ymid);
		curveVertex(x1 - delta, ymid);
		curveVertex(x1 - delta, y1);
		curveVertex(x1, y1);
		curveVertex(x1, y1);
	} else {
		xmid = x0 + (x1 - x0) / 2;
		curveVertex(x0, y0);
		curveVertex(x0, y0);
		curveVertex(xmid - 10, y0 + ydelta);
		curveVertex(xmid + 10, y1 - ydelta);
		curveVertex(x1, y1);
		curveVertex(x1, y1);
	}
	endShape();
	**/
}

void drawConnectivity() {
	noFill();
	if ( selected_input_idx != -1 ) {
		coolLine(
			selected_input_widget.getInputX(selected_input_idx),
			selected_input_widget.getInputY(selected_input_idx),
			mouseX,
			mouseY
		);
	} else if ( selected_output_idx != -1 ) {
		coolLine(
			selected_output_widget.getOutputX(selected_output_idx),
			selected_output_widget.getOutputY(selected_output_idx),
			mouseX,
			mouseY
		);
	}

	Widget w, w2;
	IOWidget io;
	int idx;
	for ( var i = 0;  i < widgets.size(); i++ ) {
		w = widgets.get(i);
		for ( var j = 0; j < w.outputs.size(); j++ ) {
			io = w.outputs.get(j);
			for ( var k = 0; k < io.observers.size(); k++ ) {
				w2 = io.observers.get(k);
				idx = io.observers_idx.get(k);
				if ( connectivity_widget == w2 || connectivity_widget == w )
					stroke(cselected);
				else
					stroke(cidle);
				coolLine(w.getOutputX(j), w.getOutputY(j),
						 w2.getInputX(idx), w2.getInputY(idx));
			}
		}
	}

	noStroke();
}

void resetHighlight() {
	$.each(mo_available_modules, function(name, module) {
		key = '#module_' + name;
		$(key).removeClass('highlight');
	});
}

void searchConnectivity() {
	Widget w;

	if ( (mouseX - oldmouseX) == 0 && (mouseY - oldmouseY) == 0 )
		return;

	connectivity_widget = null;
	connectivity_idx = -1;
	connectivity_io = '';

	for (var i = 0;  i < widgets.size(); i++ ) {
		w = widgets.get(i);
		if ( !w.collide(mouseX, mouseY) )
			continue;

		connectivity_widget = w;

		// selected an input ?
		idx = w.collideInput(mouseX, mouseY);
		if ( idx != -1 ) {
			connectivity_idx = idx;
			connectivity_io = 'input';
			break;
		}

		// selected an output ?
		idx = w.collideOutput(mouseX, mouseY);
		if ( idx != -1 ) {
			connectivity_idx = idx;
			connectivity_io = 'output';
			break;
		}
	}

	if ( connectivity_idx == -1 ) {
		resetHighlight();
		return;
	}

	// highlight module for this current index/module
	wselected = new Object();

	if ( connectivity_io == 'output' ) {
		IOWidget iow = connectivity_widget.getOutput(connectivity_idx);
		$.each(mo_available_modules, function(name, module) {
			wselected['#module_' + name] = false;
			$(module.inputs).each(function(index, item) {
				if ( !inList(iow.type, item['type'], ',') )
					return;
				wselected['#module_' + name] = true;
			});
		});
	} else if ( connectivity_io == 'input' ) {
		IOWidget iow = connectivity_widget.getInput(connectivity_idx);
		$.each(mo_available_modules, function(name, module) {
			wselected['#module_' + name] = false;
			$(module.outputs).each(function(index, item) {
				if ( !inList(item['type'], iow.type, ',') )
					return;
				wselected['#module_' + name] = true;
			});
		});
	}

	$.each(wselected, function(key, value) {
		if ( value )
			$(key).addClass('highlight');
		else
			$(key).removeClass('highlight');
	});
}

void checkConnectivity() {

	connectivity_ok = 0;

	strokeWeight(2);

	if ( connectivity_idx == -1 ) {
		stroke(cidle);
		return;
	}

	if ( selected_input_idx != -1 ) {
		if ( connectivity_io != 'output' ) {
			stroke(cko);
			return;
		}
		if ( selected_input_widget == connectivity_widget ) {
			stroke(cko);
			return;
		}
	} else if ( selected_output_idx != -1 ) {
		if ( connectivity_io != 'input' ) {
			stroke(cko);
			return;
		}
		if ( selected_output_widget == connectivity_widget ) {
			stroke(cko);
			return;
		}
	}

	connectivity_ok = 1;
	stroke(cok);
}

void searchWidgetConnection(Widget w, IOWidget iow, String iotype) {
	// update hover list to highlight all the widgets / io that
	// can be used to link the current Widget / IO
	for ( int i = 0; i < widgets.size(); i++ ) {
		w2 = widgets.get(i);
		if ( w == w2 )
			continue;
		count = 0;
		func = null;
		if ( iotype == 'output' ) {
			count = w2.getOutputCount();
			func = w2.getOutput;
		} else {
			count = w2.getInputCount();
			func = w2.getInput;
		}
		for ( int j = 0; j < count; j++ ) {
			iow2 = func(j);
			if ( iotype == 'output' ) {
				if ( !inList(iow2.type, iow.type, ',') )
					continue
			} else {
				if ( !inList(iow.type, iow2.type, ',') )
					continue
			}
			widgets_hover.add([w2, iotype, j]);
		}
	}
}

void mousePressed() {
	Widget w, w2;
	IOWidget iow, iow2;
	int idx;

	if ( config_show == 1 ) {
		configSendFeedback('down', mouseX, mouseY);
		return;
	}

	widgets_hover.clear();

	for ( int i = widgets.size() - 1; i >= 0; i-- ) {
		w = widgets.get(i);
		if ( w.collide(mouseX, mouseY) ) {
			// selected an input ?
			idx = w.collideInput(mouseX, mouseY);
			if ( idx != -1 ) {
				selected_input_widget = w;
				selected_input_idx = idx;
				iow = w.getInput(idx);
				searchWidgetConnection(w, iow, 'output');
				return;
			}

			// selected an output ?
			idx = w.collideOutput(mouseX, mouseY);
			if ( idx != -1 ) {
				selected_output_widget = w;
				selected_output_idx = idx;
				iow = w.getOutput(idx);
				searchWidgetConnection(w, iow, 'input');
				return;
			}

			// so, the widget is selected !
			selected_widget = i;
			selected_widget_x = mouseX - w.x;
			selected_widget_y = mouseY - w.y;
			selectWidget(selected_widget);
			return;
		}
	}

	selected_input_idx = -1;
	selected_output_idx = -1;
	selected_widget = -1;
	selectWidget(-1);
}

void selectWidget(int index) {
	if ( index == -1 ) {
		$('#module').html('');
		mo_select('');
		return;
	}

	Widget w = widgets.get(index);
	var name = w.name;
	mo_select(name);

	var data = [
		'<h1>Details of ', name, '</h1>',
	];

	void pushIO(data, index, io) {
		data.push('<li>');
		data.push('<span class="ioindex">');
		data.push(index);
		data.push('</span>: <span class="ioname">');
		data.push(io.name);
		data.push('</span> <span class="iotype">(');
		data.push(io.type);
		data.push(')</span>');
		data.push('</li>');
	}

	if ( w.getInputCount() ) {
		data.push('<h2>Inputs</h2><ul>');
		for ( int i = 0; i < w.getInputCount(); i++ ) {
			IOWidget io = w.getInput(i);
			pushIO(data, i, io);
		}
		data.push('</ul>');
	}

	if ( w.getOutputCount() ) {
		data.push('<h2>Outputs</h2><ul>');
		for ( int i = 0; i < w.getOutputCount(); i++ ) {
			IOWidget io = w.getOutput(i);
			pushIO(data, i, io);
		}
		data.push('</ul>');
	}

	$('#module').html(data.join(''));
}

bool inList(String pattern, String list, String separator) {
	list = list.split(separator);
	for ( int i = 0; i < list.length; i++ )
		if ( list[i] == pattern )
			return true;
	return false;
}

void mouseReleased() {

	widgets_hover.clear();

	if ( config_show == 1 ) {
		configSendFeedback('up', mouseX, mouseY);
		draw();
		return;
	}

	if ( connectivity_ok == 1 ) {
		if ( connectivity_widget != selected_output_widget ) {
			if ( selected_output_idx != -1 ) {
				selected_output_widget.outputs.get(selected_output_idx).connect(
					connectivity_widget, connectivity_idx);
				mo_connect(connectivity_widget.name, connectivity_idx, selected_output_widget.name, selected_output_idx);
			} else if ( selected_input_idx != -1 ) {
				connectivity_widget.outputs.get(connectivity_idx).connect(
					selected_input_widget, selected_input_idx);
				mo_connect(selected_input_widget.name, selected_input_idx, connectivity_widget.name, connectivity_idx);
			}
		}
		connectivity_ok = 0;
	}

	if ( selected_widget != -1 ) {
		Widget w = widgets.get(selected_widget);
		mo_set(w.name, "x", w.x);
		mo_set(w.name, "y", w.y);
	}

	selected_widget = -1;
	selected_input_idx = -1;
	selected_output_idx = -1;

	draw();
}

void mouseDragged() {
	draw();
	if ( config_show == 1 ) {
		configSendFeedback('move', mouseX, mouseY);
		return;
	}
}

</script><canvas id="movidcanvas" width="100" height="100">You need HTML5 canvas support.</canvas>
</div>
</div>

<div id="rightcolumn">
	<div class="ui-widget ui-widget-sidebar" id="container-preview">
		<div class="ui-widget-header ui-state-default ui-corner-top"><a href="#" onclick="$('#video').slideToggle('fast')">Preview</a></div>
		<div id="video" class="ui-widget-content ui-corner-bottom">
			<p id="streamid">No video</p>
			<img src="/gui/nostream.png" id="streamimg"/>
		</div>
	</div>
	<div class="ui-widget ui-widget-sidebar" id="container-module">
		<div class="ui-widget-header ui-state-default ui-corner-top"><a onclick="$('#module').slideToggle('fast')">Module</a></div>
		<div id="module" class="ui-widget-content ui-corner-bottom">
		</div>
	</div>
	<div class="ui-widget ui-widget-sidebar" id="container-properties">
		<div class="ui-widget-header ui-state-default ui-corner-top"><a onclick="$('#properties').slideToggle('fast')">Properties</a></div>
		<div id="properties" class="ui-widget-content ui-corner-bottom">
		</div>
	</div>
</div>

</div>
<div id="footer">
	framecount:<span id="framecount">0</span>
</div>
</body>
</html>
